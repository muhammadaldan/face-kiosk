{"version":3,"sources":["useModel.js","object-detection-video/useWebcam.js","object-detection-video/retina-canvas.js","object-detection-video/render-predictions.js","object-detection-video/ObjectDetectionVideo.js","index.js"],"names":["useModel","modelPath","_useState","useState","_useState2","Object","slicedToArray","model","setModel","useEffect","models","load","then","useWebcam","videoRef","onLoaded","navigator","mediaDevices","getUserMedia","audio","video","facingMode","width","ideal","height","stream","current","srcObject","onloadedmetadata","getRetinaContext","canvas","ctx","getContext","scale","window","devicePixelRatio","setWidth","w","style","setHeight","h","clearAll","clearRect","x","y","setFont","font","size","parseInt","retinaFont","replace","setTextBaseLine","textBaseline","setStrokeStyle","strokeStyle","setLineWidth","lineWidth","strokeRect","setFillStyle","fillStyle","measureText","text","metrics","actualBoundingBoxLeft","actualBoundingBoxRight","actualBoundingBoxAscent","actualBoundingBoxDescent","fillRect","fillText","client","require","connect","getLabelText","prediction","scoreText","score","toFixed","concat","label","renderPredictions","predictions","textHeight","forEach","bbox","predictionText","dataSend","publish","includes","Math","round","textWidth","border","xPadding","yPadding","ObjectDetectionVideo","React","memo","_ref","onPrediction","fit","mirrored","render","useRef","canvasRef","detectFrame","useCallback","asyncToGenerator","regenerator_default","a","mark","_callee","wantedWidth","wantedHeight","videoWidth","videoHeight","scaleX","scaleY","xOffset","yOffset","offsetPredictions","wrap","_context","prev","next","detect","sent","offsetWidth","offsetHeight","min","max","map","objectSpread2","requestAnimationFrame","stop","position","left","top","objectFit","transform","react_default","createElement","autoPlay","playsInline","muted","ref","App","className","object_detection_video_ObjectDetectionVideo","rootElement","document","getElementById","ReactDOM","src_App"],"mappings":"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","file":"static/js/main.b07ee34b.chunk.js","sourcesContent":["import { useEffect, useState } from 'react'\r\n\r\nimport models from '@cloud-annotations/models'\r\n\r\nconst useModel = (modelPath) => {\r\n  const [model, setModel] = useState()\r\n  useEffect(() => {\r\n    models.load(modelPath).then((model) => {\r\n      setModel(model)\r\n    })\r\n  }, [modelPath])\r\n  return model\r\n}\r\n\r\nexport default useModel\r\n","import { useEffect } from 'react'\r\n\r\nconst useWebcam = (videoRef, onLoaded) => {\r\n  useEffect(() => {\r\n    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\r\n      navigator.mediaDevices\r\n        .getUserMedia({\r\n          audio: false,\r\n          video: {\r\n            facingMode: 'user',\r\n            width: { ideal: 4096 },\r\n            height: { ideal: 2160 },\r\n          },\r\n        })\r\n        .then((stream) => {\r\n          videoRef.current.srcObject = stream\r\n          videoRef.current.onloadedmetadata = () => {\r\n            onLoaded()\r\n          }\r\n        })\r\n    }\r\n  }, [onLoaded, videoRef])\r\n}\r\n\r\nexport default useWebcam\r\n","export const getRetinaContext = (canvas) => {\r\n  const ctx = canvas.getContext('2d')\r\n  const scale = window.devicePixelRatio\r\n  let width = canvas.width / scale\r\n  let height = canvas.height / scale\r\n  return {\r\n    setWidth: (w) => {\r\n      width = w\r\n      canvas.style.width = w + 'px'\r\n      canvas.width = w * scale\r\n    },\r\n    setHeight: (h) => {\r\n      height = h\r\n      canvas.style.height = h + 'px'\r\n      canvas.height = h * scale\r\n    },\r\n    width: width,\r\n    height: height,\r\n    clearAll: () => {\r\n      return ctx.clearRect(0, 0, width * scale, height * scale)\r\n    },\r\n    clearRect: (x, y, width, height) => {\r\n      return ctx.clearRect(x * scale, y * scale, width * scale, height * scale)\r\n    },\r\n    setFont: (font) => {\r\n      const size = parseInt(font, 10) * scale\r\n      const retinaFont = font.replace(/^\\d+px/, size + 'px')\r\n      ctx.font = retinaFont\r\n    },\r\n    setTextBaseLine: (textBaseline) => {\r\n      ctx.textBaseline = textBaseline\r\n    },\r\n    setStrokeStyle: (strokeStyle) => {\r\n      ctx.strokeStyle = strokeStyle\r\n    },\r\n    setLineWidth: (lineWidth) => {\r\n      ctx.lineWidth = lineWidth * scale\r\n    },\r\n    strokeRect: (x, y, width, height) => {\r\n      return ctx.strokeRect(x * scale, y * scale, width * scale, height * scale)\r\n    },\r\n    setFillStyle: (fillStyle) => {\r\n      ctx.fillStyle = fillStyle\r\n    },\r\n    measureText: (text) => {\r\n      const metrics = ctx.measureText(text)\r\n      return {\r\n        width: metrics.width / scale,\r\n        actualBoundingBoxLeft: metrics.actualBoundingBoxLeft / scale,\r\n        actualBoundingBoxRight: metrics.actualBoundingBoxRight / scale,\r\n        actualBoundingBoxAscent: metrics.actualBoundingBoxAscent / scale,\r\n        actualBoundingBoxDescent: metrics.actualBoundingBoxDescent / scale,\r\n      }\r\n    },\r\n    fillRect: (x, y, width, height) => {\r\n      return ctx.fillRect(x * scale, y * scale, width * scale, height * scale)\r\n    },\r\n    fillText: (text, x, y) => {\r\n      return ctx.fillText(text, x * scale, y * scale)\r\n    },\r\n  }\r\n}\r\n","const mqtt = require(\"mqtt\");\r\nconst client = mqtt.connect(\"mqtt://127.0.0.1:1884\");\r\n\r\nconst getLabelText = (prediction) => {\r\n  const scoreText = (prediction.score * 100).toFixed(1);\r\n  return `${prediction.label} ${scoreText}%`;\r\n};\r\n\r\nexport const renderPredictions = (ctx, predictions) => {\r\n  // Font options.\r\n  const font = `${16}px 'ibm-plex-sans', Helvetica Neue, Arial, sans-serif`;\r\n  ctx.setFont(font);\r\n  ctx.setTextBaseLine(\"top\");\r\n  const border = 4;\r\n  const xPadding = 16;\r\n  const yPadding = 8;\r\n  const offset = 6;\r\n  const textHeight = parseInt(font, 10); // base 10\r\n  // if (predictions.length === 0) {\r\n  //   client.publish(\"data\", \"no,#\");\r\n  // }\r\n\r\n  predictions.forEach((prediction) => {\r\n    const x = prediction.bbox[0];\r\n    const y = prediction.bbox[1];\r\n    const width = prediction.bbox[2];\r\n    const height = prediction.bbox[3];\r\n\r\n    const predictionText = getLabelText(prediction);\r\n    const dataSend = predictionText[0] == \"M\" ? \"true,#\" : \"false,#\";\r\n    client.publish(\"data\", dataSend);\r\n    // console.log(predictionText);\r\n    // console.log(predictionText.includes(\"No\"));\r\n    if (predictionText.includes(\"No\")) {\r\n      // Draw the bounding box.\r\n      //console.log(predictionText)\r\n      ctx.setStrokeStyle(\"#FF0000\");\r\n      ctx.setLineWidth(border);\r\n    } else {\r\n      ctx.setStrokeStyle(\"#00FF00\");\r\n      ctx.setLineWidth(border);\r\n    }\r\n\r\n    ctx.strokeRect(\r\n      Math.round(x),\r\n      Math.round(y),\r\n      Math.round(width),\r\n      Math.round(height)\r\n    );\r\n    // Draw the label background.\r\n    if (predictionText.includes(\"No\")) {\r\n      ctx.setFillStyle(\"#FF0000\");\r\n    } else {\r\n      ctx.setFillStyle(\"#00FF00\");\r\n    }\r\n    const textWidth = ctx.measureText(predictionText).width;\r\n    ctx.fillRect(\r\n      Math.round(x - border / 2),\r\n      Math.round(y - (textHeight + yPadding) - offset),\r\n      Math.round(textWidth + xPadding),\r\n      Math.round(textHeight + yPadding)\r\n    );\r\n  });\r\n\r\n  predictions.forEach((prediction) => {\r\n    const x = prediction.bbox[0];\r\n    const y = prediction.bbox[1];\r\n\r\n    const predictionText = getLabelText(prediction);\r\n    // Draw the text last to ensure it's on top.\r\n    ctx.setFillStyle(\"#ffffff\");\r\n    ctx.fillText(\r\n      predictionText,\r\n      Math.round(x - border / 2 + xPadding / 2),\r\n      Math.round(y - (textHeight + yPadding) - offset + yPadding / 2)\r\n    );\r\n  });\r\n};\r\n","import React, { useRef, useCallback } from \"react\";\r\n\r\nimport useWebcam from \"./useWebcam\";\r\nimport { getRetinaContext } from \"./retina-canvas\";\r\nimport { renderPredictions } from \"./render-predictions\";\r\n\r\nconst ObjectDetectionVideo = React.memo(\r\n  ({ model, onPrediction, fit, mirrored, render }) => {\r\n    const videoRef = useRef();\r\n    const canvasRef = useRef();\r\n\r\n    useWebcam(videoRef, () => {\r\n      detectFrame();\r\n    });\r\n\r\n    const detectFrame = useCallback(async () => {\r\n      const predictions = await model.detect(videoRef.current);\r\n      if (onPrediction) {\r\n        onPrediction(predictions);\r\n      }\r\n\r\n      const wantedWidth = videoRef.current.offsetWidth;\r\n      const wantedHeight = videoRef.current.offsetHeight;\r\n      const videoWidth = videoRef.current.videoWidth;\r\n      const videoHeight = videoRef.current.videoHeight;\r\n\r\n      const scaleX = wantedWidth / videoWidth;\r\n      const scaleY = wantedHeight / videoHeight;\r\n\r\n      let scale;\r\n      if (fit === \"aspectFit\") {\r\n        scale = Math.min(scaleX, scaleY);\r\n      } else {\r\n        scale = Math.max(scaleX, scaleY);\r\n      }\r\n\r\n      const xOffset = (wantedWidth - videoWidth * scale) / 2;\r\n      const yOffset = (wantedHeight - videoHeight * scale) / 2;\r\n\r\n      const ctx = getRetinaContext(canvasRef.current);\r\n\r\n      ctx.setWidth(wantedWidth);\r\n      ctx.setHeight(wantedHeight);\r\n      ctx.clearAll();\r\n\r\n      // Update predictions to match canvas.\r\n      const offsetPredictions = predictions.map((prediction) => {\r\n        let x = prediction.bbox[0] * scale + xOffset;\r\n        const y = prediction.bbox[1] * scale + yOffset;\r\n        const width = prediction.bbox[2] * scale;\r\n        const height = prediction.bbox[3] * scale;\r\n\r\n        if (mirrored) {\r\n          x = wantedWidth - x - width;\r\n        }\r\n        return { ...prediction, bbox: [x, y, width, height] };\r\n      });\r\n\r\n      const renderFunction = render || renderPredictions;\r\n\r\n      renderFunction(ctx, offsetPredictions);\r\n      requestAnimationFrame(() => {\r\n        detectFrame();\r\n      });\r\n    }, [fit, mirrored, model, onPrediction, render]);\r\n\r\n    if (canvasRef.current) {\r\n      canvasRef.current.style.position = \"absolute\";\r\n      canvasRef.current.style.left = \"0\";\r\n      canvasRef.current.style.top = \"0\";\r\n    }\r\n\r\n    if (videoRef.current) {\r\n      videoRef.current.style.width = \"100%\";\r\n      videoRef.current.style.height = \"100%\";\r\n      if (fit === \"aspectFit\") {\r\n        videoRef.current.style.objectFit = \"contain\";\r\n      } else {\r\n        videoRef.current.style.objectFit = \"cover\";\r\n      }\r\n\r\n      if (mirrored) {\r\n        videoRef.current.style.transform = \"scaleX(-1)\";\r\n      } else {\r\n        videoRef.current.style.transform = \"scaleX(1)\";\r\n      }\r\n    }\r\n\r\n    return (\r\n      <div style={{ position: \"relative\" }}>\r\n        <video autoPlay playsInline muted ref={videoRef} />\r\n        <canvas ref={canvasRef} />\r\n      </div>\r\n    );\r\n  }\r\n);\r\n\r\nexport default ObjectDetectionVideo;\r\n","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\n\r\nimport useModel from \"./useModel\";\r\nimport ObjectDetectionVideo from \"./object-detection-video/ObjectDetectionVideo\";\r\n\r\nimport \"./index.css\";\r\n\r\nconst handlePrediction = (predictions) => {\r\n  console.timeEnd(\"detect\");\r\n  console.time(\"detect\");\r\n  console.log(predictions);\r\n};\r\n\r\nconst render = (ctx, predictions) => {\r\n  predictions.forEach((prediction) => {\r\n    const x = prediction.bbox[0];\r\n    const y = prediction.bbox[1];\r\n    const width = prediction.bbox[2];\r\n    const height = prediction.bbox[3];\r\n\r\n    ctx.setStrokeStyle(\"#0062ff\");\r\n    ctx.setLineWidth(4);\r\n    ctx.strokeRect(\r\n      Math.round(x),\r\n      Math.round(y),\r\n      Math.round(width),\r\n      Math.round(height)\r\n    );\r\n  });\r\n};\r\n\r\nconst App = () => {\r\n  const model = useModel(process.env.PUBLIC_URL + \"/model_web\");\r\n\r\n  return (\r\n    <div className=\"fillPage\">\r\n      <ObjectDetectionVideo\r\n        model={model}\r\n        // onPrediction={handlePrediction}\r\n        // render={render}\r\n        // aspectFill: The option to scale the video to fill the size of the view.\r\n        //             Some portion of the video may be clipped to fill the view's\r\n        //             bounds.\r\n        // aspectFit:  The option to scale the video to fit the size of the view\r\n        //             by maintaining the aspect ratio. Any remaining area of the\r\n        //             view's bounds is transparent.\r\n        fit=\"aspectFill\"\r\n        // mirrored:   mirror the video about its vertical axis.\r\n        mirrored\r\n      />\r\n    </div>\r\n  );\r\n};\r\n\r\nconst rootElement = document.getElementById(\"root\");\r\nReactDOM.render(<App />, rootElement);\r\n"],"sourceRoot":""}